import telebot
import requests
import time
import json
import os
import random
import string
import sys # Import sys for stdout.flush for immediate log output
from datetime import datetime, timedelta
from threading import Thread, Event, Lock
from flask import Flask, request

# --- C·∫•u h√¨nh Bot (ƒê·∫∂T TR·ª∞C TI·∫æP T·∫†I ƒê√ÇY) ---
BOT_TOKEN = "7820739987:AAE_eU2JPZH7u6KnDRq31_l4tn64AD_8f6s" 
ADMIN_IDS = [6915752059] # V√≠ d·ª•: [6915752059, 123456789]

DATA_FILE = 'user_data.json'
CAU_PATTERNS_FILE = 'cau_patterns.json'
CODES_FILE = 'codes.json'
BOT_STATUS_FILE = 'bot_status.json' # File ƒë·ªÉ l∆∞u tr·∫°ng th√°i bot

# --- Kh·ªüi t·∫°o Flask App v√† Telegram Bot ---
app = Flask(__name__)
bot = telebot.TeleBot(BOT_TOKEN)

# Global flags v√† objects
bot_enabled = True
bot_disable_reason = "Kh√¥ng c√≥"
bot_disable_admin_id = None
prediction_stop_events = {} # Dictionary of Events for each game's prediction thread
bot_initialized = False # C·ªù ƒë·ªÉ ƒë·∫£m b·∫£o bot ch·ªâ ƒë∆∞·ª£c kh·ªüi t·∫°o m·ªôt l·∫ßn
bot_init_lock = Lock() # Kh√≥a ƒë·ªÉ tr√°nh race condition khi kh·ªüi t·∫°o

# Global sets for patterns and codes
# M·∫´u c·∫ßu s·∫Ω ƒë∆∞·ª£c l∆∞u theo t·ª´ng game
CAU_DEP = {} # {'luckywin': set(), 'hitclub': set(), 'sunwin': set()}
CAU_XAU = {} # {'luckywin': set(), 'hitclub': set(), 'sunwin': set()}
GENERATED_CODES = {} # {code: {"value": 1, "type": "day", "used_by": null, "used_time": null}}

# Game specific configurations
GAME_CONFIGS = {
    'luckywin': {
        'api_url': "https://1.bot/GetNewLottery/LT_Taixiu",
        'prediction_enabled': True,
        'maintenance_mode': False,
        'maintenance_reason': "",
        'game_name_vi': "Luckywin",
        'prediction_stats': {'correct': 0, 'wrong': 0, 'total': 0},
        'users_receiving': set() # Users currently receiving predictions for this game
    },
    'hitclub': {
        'api_url': "https://apihitclub.up.railway.app/api/taixiu",
        'prediction_enabled': True,
        'maintenance_mode': False,
        'maintenance_reason': "",
        'game_name_vi': "Hit Club",
        'prediction_stats': {'correct': 0, 'wrong': 0, 'total': 0},
        'users_receiving': set()
    },
    'sunwin': {
        'api_url': "https://wanglinapiws.up.railway.app/api/taixiu",
        'prediction_enabled': True,
        'maintenance_mode': False,
        'maintenance_reason': "",
        'game_name_vi': "Sunwin",
        'prediction_stats': {'correct': 0, 'wrong': 0, 'total': 0},
        'users_receiving': set()
    }
}

# --- Qu·∫£n l√Ω d·ªØ li·ªáu ng∆∞·ªùi d√πng, m·∫´u c·∫ßu v√† code ---
user_data = {} # {user_id: {username, expiry_date, is_ctv, banned, ban_reason, override_maintenance, receiving_games: {'luckywin': True, 'hitclub': True, 'sunwin': True}}}

def load_json_file(filepath, default_value):
    if os.path.exists(filepath):
        with open(filepath, 'r', encoding='utf-8') as f:
            try:
                data = json.load(f)
                print(f"DEBUG: T·∫£i {len(data)} b·∫£n ghi t·ª´ {filepath}")
                return data
            except json.JSONDecodeError:
                print(f"L·ªñI: L·ªói ƒë·ªçc {filepath}. Kh·ªüi t·∫°o l·∫°i d·ªØ li·ªáu.")
                return default_value
            except Exception as e:
                print(f"L·ªñI: L·ªói kh√¥ng x√°c ƒë·ªãnh khi t·∫£i {filepath}: {e}")
                return default_value
    else:
        print(f"DEBUG: File {filepath} kh√¥ng t·ªìn t·∫°i. Kh·ªüi t·∫°o d·ªØ li·ªáu r·ªóng.")
        return default_value

def save_json_file(filepath, data):
    try:
        with open(filepath, 'w', encoding='utf-8') as f:
            json.dump(data, f, indent=4, ensure_ascii=False)
    except Exception as e:
        print(f"L·ªñI: Kh√¥ng th·ªÉ l∆∞u d·ªØ li·ªáu v√†o {filepath}: {e}")
    sys.stdout.flush()

def load_user_data():
    global user_data
    user_data = load_json_file(DATA_FILE, {})
    # ƒê·∫£m b·∫£o c√°c tr∆∞·ªùng m·ªõi t·ªìn t·∫°i trong user_data c≈©
    for user_id_str, u_data in user_data.items():
        u_data.setdefault('banned', False)
        u_data.setdefault('ban_reason', None)
        u_data.setdefault('override_maintenance', False)
        # Kh·ªüi t·∫°o receiving_games n·∫øu ch∆∞a c√≥
        u_data.setdefault('receiving_games', {game: True for game in GAME_CONFIGS.keys()})
        # C·∫≠p nh·∫≠t users_receiving set trong GAME_CONFIGS
        for game_name, config in GAME_CONFIGS.items():
            if u_data['receiving_games'].get(game_name, False) and not u_data['banned']:
                config['users_receiving'].add(int(user_id_str))
    save_user_data(user_data) # L∆∞u l·∫°i ƒë·ªÉ c·∫≠p nh·∫≠t schema

def save_user_data(data):
    save_json_file(DATA_FILE, data)

def load_cau_patterns():
    global CAU_DEP, CAU_XAU
    loaded_patterns = load_json_file(CAU_PATTERNS_FILE, {})
    for game_name in GAME_CONFIGS.keys():
        CAU_DEP[game_name] = set(loaded_patterns.get(game_name, {}).get('dep', []))
        CAU_XAU[game_name] = set(loaded_patterns.get(game_name, {}).get('xau', []))
        print(f"DEBUG: T·∫£i {len(CAU_DEP[game_name])} m·∫´u c·∫ßu ƒë·∫πp v√† {len(CAU_XAU[game_name])} m·∫´u c·∫ßu x·∫•u cho {game_name}.")
    sys.stdout.flush()

def save_cau_patterns():
    patterns_to_save = {}
    for game_name in GAME_CONFIGS.keys():
        patterns_to_save[game_name] = {
            'dep': list(CAU_DEP.get(game_name, set())),
            'xau': list(CAU_XAU.get(game_name, set()))
        }
    save_json_file(CAU_PATTERNS_FILE, patterns_to_save)

def load_codes():
    global GENERATED_CODES
    GENERATED_CODES = load_json_file(CODES_FILE, {})

def save_codes():
    save_json_file(CODES_FILE, GENERATED_CODES)

def load_bot_status():
    global bot_enabled, bot_disable_reason, bot_disable_admin_id, GAME_CONFIGS
    status = load_json_file(BOT_STATUS_FILE, {})
    bot_enabled = status.get('bot_enabled', True)
    bot_disable_reason = status.get('bot_disable_reason', "Kh√¥ng c√≥")
    bot_disable_admin_id = status.get('bot_disable_admin_id')

    for game_name, config in GAME_CONFIGS.items():
        game_status = status.get('game_configs', {}).get(game_name, {})
        config['prediction_enabled'] = game_status.get('prediction_enabled', True)
        config['maintenance_mode'] = game_status.get('maintenance_mode', False)
        config['maintenance_reason'] = game_status.get('maintenance_reason', "")
        config['prediction_stats'] = game_status.get('prediction_stats', {'correct': 0, 'wrong': 0, 'total': 0})
    print("DEBUG: T·∫£i tr·∫°ng th√°i bot v√† game.")
    sys.stdout.flush()

def save_bot_status():
    status = {
        'bot_enabled': bot_enabled,
        'bot_disable_reason': bot_disable_reason,
        'bot_disable_admin_id': bot_disable_admin_id,
        'game_configs': {}
    }
    for game_name, config in GAME_CONFIGS.items():
        status['game_configs'][game_name] = {
            'prediction_enabled': config['prediction_enabled'],
            'maintenance_mode': config['maintenance_mode'],
            'maintenance_reason': config['maintenance_reason'],
            'prediction_stats': config['prediction_stats']
        }
    save_json_file(BOT_STATUS_FILE, status)
    print("DEBUG: L∆∞u tr·∫°ng th√°i bot v√† game.")
    sys.stdout.flush()

def is_admin(user_id):
    return user_id in ADMIN_IDS

def is_ctv(user_id):
    return is_admin(user_id) or (str(user_id) in user_data and user_data[str(user_id)].get('is_ctv'))

def is_banned(user_id):
    return str(user_id) in user_data and user_data[str(user_id)].get('banned', False)

def can_override_maintenance(user_id):
    return is_admin(user_id) or (str(user_id) in user_data and user_data[str(user_id)].get('override_maintenance', False))

def check_subscription(user_id):
    user_id_str = str(user_id)
    if is_banned(user_id):
        return False, f"üö´ B·∫°n ƒë√£ b·ªã c·∫•m s·ª≠ d·ª•ng bot. L√Ω do: `{user_data[user_id_str].get('ban_reason', 'Kh√¥ng r√µ')}`"

    if is_admin(user_id) or is_ctv(user_id):
        return True, "B·∫°n l√† Admin/CTV, quy·ªÅn truy c·∫≠p vƒ©nh vi·ªÖn."

    if user_id_str not in user_data or user_data[user_id_str].get('expiry_date') is None:
        return False, "‚ö†Ô∏è B·∫°n ch∆∞a ƒëƒÉng k√Ω ho·∫∑c t√†i kho·∫£n ch∆∞a ƒë∆∞·ª£c gia h·∫°n."

    expiry_date_str = user_data[user_id_str]['expiry_date']
    expiry_date = datetime.strptime(expiry_date_str, '%Y-%m-%d %H:%M:%S')

    if datetime.now() < expiry_date:
        remaining_time = expiry_date - datetime.now()
        days = remaining_time.days
        hours = remaining_time.seconds // 3600
        minutes = (remaining_time.seconds % 3600) // 60
        seconds = remaining_time.seconds % 60
        return True, f"‚úÖ T√†i kho·∫£n c·ªßa b·∫°n c√≤n h·∫°n ƒë·∫øn: `{expiry_date_str}` ({days} ng√†y {hours} gi·ªù {minutes} ph√∫t {seconds} gi√¢y)."
    else:
        return False, "‚ùå T√†i kho·∫£n c·ªßa b·∫°n ƒë√£ h·∫øt h·∫°n."

# --- Logic d·ª± ƒëo√°n T√†i X·ªâu ---
def du_doan_theo_xi_ngau(dice_list):
    if not dice_list:
        return "ƒê·ª£i th√™m d·ªØ li·ªáu"
    d1, d2, d3 = dice_list[-1]
    total = d1 + d2 + d3

    # Logic d·ª± ƒëo√°n d·ª±a tr√™n t·ªïng v√† t·ª´ng con x√∫c x·∫Øc
    # ƒê√¢y l√† m·ªôt v√≠ d·ª•, c√≥ th·ªÉ ph·ª©c t·∫°p h∆°n
    if total <= 10: # X·ªâu
        if sum([d for d in dice_list[-1] if d % 2 == 0]) >= sum([d for d in dice_list[-1] if d % 2 != 0]):
            return "T√†i"
        else:
            return "X·ªâu"
    else: # T√†i
        if sum([d for d in dice_list[-1] if d % 2 != 0]) >= sum([d for d in dice_list[-1] if d % 2 == 0]):
            return "X·ªâu"
        else:
            return "T√†i"

def tinh_tai_xiu(dice):
    total = sum(dice)
    if total == 3 or total == 18:
        return "B√£o", total # B√£o 3 ho·∫∑c B√£o 18
    return "T√†i" if total >= 11 else "X·ªâu", total

# --- C·∫≠p nh·∫≠t m·∫´u c·∫ßu ƒë·ªông ---
def update_cau_patterns(game_name, new_cau, prediction_correct):
    global CAU_DEP, CAU_XAU
    if prediction_correct:
        CAU_DEP.setdefault(game_name, set()).add(new_cau)
        if new_cau in CAU_XAU.setdefault(game_name, set()):
            CAU_XAU[game_name].remove(new_cau)
            print(f"DEBUG: X√≥a m·∫´u c·∫ßu '{new_cau}' kh·ªèi c·∫ßu x·∫•u cho {game_name}.")
    else:
        CAU_XAU.setdefault(game_name, set()).add(new_cau)
        if new_cau in CAU_DEP.setdefault(game_name, set()):
            CAU_DEP[game_name].remove(new_cau)
            print(f"DEBUG: X√≥a m·∫´u c·∫ßu '{new_cau}' kh·ªèi c·∫ßu ƒë·∫πp cho {game_name}.")
    save_cau_patterns()
    sys.stdout.flush()

def is_cau_xau(game_name, cau_str):
    return cau_str in CAU_XAU.get(game_name, set())

def is_cau_dep(game_name, cau_str):
    return cau_str in CAU_DEP.get(game_name, set()) and cau_str not in CAU_XAU.get(game_name, set()) # ƒê·∫£m b·∫£o kh√¥ng tr√πng c·∫ßu x·∫•u

# --- L·∫•y d·ªØ li·ªáu t·ª´ API ---
def lay_du_lieu(game_name):
    config = GAME_CONFIGS[game_name]
    url = config['api_url']
    try:
        response = requests.get(url, timeout=10)
        response.raise_for_status() 
        data = response.json()
        
        # Normalize data structure for different APIs
        if game_name == 'luckywin':
            if data.get("state") != 1:
                print(f"DEBUG: API {game_name} tr·∫£ v·ªÅ state kh√¥ng th√†nh c√¥ng: {data.get('state')}. Ph·∫£n h·ªìi ƒë·∫ßy ƒë·ªß: {data}")
                sys.stdout.flush()
                return None
            return data.get("data")
        elif game_name in ['hitclub', 'sunwin']:
            # Hit Club and Sunwin API directly return the result object
            if "Ket_qua" not in data or "Phien" not in data or "Tong" not in data:
                 print(f"DEBUG: API {game_name} kh√¥ng c√≥ ƒë·ªß tr∆∞·ªùng c·∫ßn thi·∫øt. Ph·∫£n h·ªìi ƒë·∫ßy ƒë·ªß: {data}")
                 sys.stdout.flush()
                 return None
            
            # Map their keys to a common format
            return {
                "ID": str(data.get("Phien")),
                "Expect": str(data.get("Phien")),
                "OpenCode": f"{data.get('Xuc_xac_1')},{data.get('Xuc_xac_2')},{data.get('Xuc_xac_3')}",
                "Ket_qua_raw": data.get("Ket_qua") # Keep raw result for debugging if needed
            }
        else:
            print(f"L·ªñI: Game {game_name} kh√¥ng ƒë∆∞·ª£c c·∫•u h√¨nh API.")
            return None

    except requests.exceptions.Timeout:
        print(f"L·ªñI: H·∫øt th·ªùi gian ch·ªù khi l·∫•y d·ªØ li·ªáu t·ª´ API {game_name}: {url}")
        sys.stdout.flush()
        return None
    except requests.exceptions.ConnectionError as e:
        print(f"L·ªñI: L·ªói k·∫øt n·ªëi khi l·∫•y d·ªØ li·ªáu t·ª´ API {game_name}: {url} - {e}")
        sys.stdout.flush()
        return None
    except requests.exceptions.RequestException as e:
        print(f"L·ªñI: L·ªói HTTP ho·∫∑c Request kh√°c khi l·∫•y d·ªØ li·ªáu t·ª´ API {game_name}: {url} - {e}")
        sys.stdout.flush()
        return None
    except json.JSONDecodeError:
        print(f"L·ªñI: L·ªói gi·∫£i m√£ JSON t·ª´ API {game_name} ({url}). Ph·∫£n h·ªìi kh√¥ng ph·∫£i JSON h·ª£p l·ªá ho·∫∑c tr·ªëng.")
        print(f"DEBUG: Ph·∫£n h·ªìi th√¥ nh·∫≠n ƒë∆∞·ª£c t·ª´ {game_name}: {response.text}")
        sys.stdout.flush()
        return None
    except Exception as e:
        print(f"L·ªñI: L·ªói kh√¥ng x√°c ƒë·ªãnh khi l·∫•y d·ªØ li·ªáu API {game_name} ({url}): {e}")
        sys.stdout.flush()
        return None

# --- Logic ch√≠nh c·ªßa Bot d·ª± ƒëo√°n (ch·∫°y trong lu·ªìng ri√™ng) ---
def prediction_loop(game_name, stop_event: Event):
    last_id = None
    tx_history = [] # L·ªãch s·ª≠ T√†i/X·ªâu/B√£o c·ªßa 5 phi√™n g·∫ßn nh·∫•t
    
    print(f"LOG: Lu·ªìng d·ª± ƒëo√°n cho {game_name} ƒë√£ kh·ªüi ƒë·ªông.")
    sys.stdout.flush()

    while not stop_event.is_set():
        config = GAME_CONFIGS[game_name]

        if not bot_enabled:
            # print(f"LOG: Bot d·ª± ƒëo√°n to√†n c·ª•c ƒëang t·∫°m d·ª´ng. L√Ω do: {bot_disable_reason}")
            time.sleep(10) 
            continue
        
        if not config['prediction_enabled']:
            # print(f"LOG: Bot d·ª± ƒëo√°n cho {game_name} ƒëang t·∫°m d·ª´ng.")
            time.sleep(10)
            continue

        if config['maintenance_mode']:
            # print(f"LOG: Game {game_name} ƒëang b·∫£o tr√¨. L√Ω do: {config['maintenance_reason']}")
            time.sleep(10)
            continue

        data = lay_du_lieu(game_name)
        if not data:
            print(f"LOG: ‚ùå {game_name}: Kh√¥ng l·∫•y ƒë∆∞·ª£c d·ªØ li·ªáu t·ª´ API ho·∫∑c d·ªØ li·ªáu kh√¥ng h·ª£p l·ªá. ƒêang ch·ªù phi√™n m·ªõi...")
            sys.stdout.flush()
            time.sleep(5)
            continue

        issue_id = data.get("ID")
        expect = data.get("Expect")
        open_code = data.get("OpenCode")

        if not all([issue_id, expect, open_code]):
            print(f"LOG: {game_name}: D·ªØ li·ªáu API kh√¥ng ƒë·∫ßy ƒë·ªß (thi·∫øu ID, Expect, ho·∫∑c OpenCode) cho phi√™n {expect}. B·ªè qua phi√™n n√†y. D·ªØ li·ªáu: {data}")
            sys.stdout.flush()
            time.sleep(5)
            continue

        if issue_id != last_id:
            try:
                dice = tuple(map(int, open_code.split(",")))
                if len(dice) != 3: 
                    raise ValueError("OpenCode kh√¥ng ch·ª©a 3 gi√° tr·ªã x√∫c x·∫Øc.")
            except ValueError as e:
                print(f"L·ªñI: {game_name}: L·ªói ph√¢n t√≠ch OpenCode: '{open_code}'. {e}. B·ªè qua phi√™n n√†y.")
                sys.stdout.flush()
                last_id = issue_id 
                time.sleep(5)
                continue
            except Exception as e:
                print(f"L·ªñI: {game_name}: L·ªói kh√¥ng x√°c ƒë·ªãnh khi x·ª≠ l√Ω OpenCode '{open_code}': {e}. B·ªè qua phi√™n n√†y.")
                sys.stdout.flush()
                last_id = issue_id
                time.sleep(5)
                continue
            
            ket_qua_tx, tong = tinh_tai_xiu(dice)

            # L∆∞u l·ªãch s·ª≠ 5 phi√™n
            if len(tx_history) >= 5:
                tx_history.pop(0)
            tx_history.append("T" if ket_qua_tx == "T√†i" else ("X" if ket_qua_tx == "X·ªâu" else "B")) # Th√™m 'B' cho B√£o

            next_expect = str(int(expect) + 1).zfill(len(expect))
            du_doan = du_doan_theo_xi_ngau([dice])

            ly_do = ""
            current_cau = ""

            if len(tx_history) < 5:
                ly_do = "AI D·ª± ƒëo√°n theo x√≠ ng·∫ßu (ch∆∞a ƒë·ªß m·∫´u c·∫ßu)"
            else:
                current_cau = ''.join(tx_history)
                if is_cau_dep(game_name, current_cau):
                    ly_do = f"AI C·∫ßu ƒë·∫πp ({current_cau}) ‚Üí Gi·ªØ nguy√™n k·∫øt qu·∫£"
                elif is_cau_xau(game_name, current_cau):
                    du_doan = "X·ªâu" if du_doan == "T√†i" else "T√†i" # ƒê·∫£o chi·ªÅu
                    ly_do = f"AI C·∫ßu x·∫•u ({current_cau}) ‚Üí ƒê·∫£o chi·ªÅu k·∫øt qu·∫£"
                else:
                    ly_do = f"AI Kh√¥ng r√µ m·∫´u c·∫ßu ({current_cau}) ‚Üí D·ª± ƒëo√°n theo x√≠ ng·∫ßu"
            
            # C·∫≠p nh·∫≠t m·∫´u c·∫ßu d·ª±a tr√™n k·∫øt qu·∫£ th·ª±c t·∫ø
            if len(tx_history) >= 5:
                # Ch·ªâ c·∫≠p nh·∫≠t m·∫´u c·∫ßu n·∫øu kh√¥ng ph·∫£i l√† B√£o
                if ket_qua_tx != "B√£o":
                    prediction_correct = (du_doan == "T√†i" and ket_qua_tx == "T√†i") or \
                                         (du_doan == "X·ªâu" and ket_qua_tx == "X·ªâu")
                    update_cau_patterns(game_name, current_cau, prediction_correct)
                    print(f"DEBUG: {game_name}: C·∫≠p nh·∫≠t m·∫´u c·∫ßu: '{current_cau}' - Ch√≠nh x√°c: {prediction_correct}")
                else:
                    print(f"DEBUG: {game_name}: Kh√¥ng c·∫≠p nh·∫≠t m·∫´u c·∫ßu do l√† k·∫øt qu·∫£ B√£o.")
                sys.stdout.flush()

            # C·∫≠p nh·∫≠t th·ªëng k√™
            config['prediction_stats']['total'] += 1
            if du_doan == ket_qua_tx:
                config['prediction_stats']['correct'] += 1
            else:
                config['prediction_stats']['wrong'] += 1
            save_bot_status() # Save stats

            prediction_message = (
                f"üé≤ **[{config['game_name_vi'].upper()}] K·∫æT QU·∫¢ PHI√äN HI·ªÜN T·∫†I** üé≤\n"
                f"Phi√™n: `{expect}` | K·∫øt qu·∫£: **{ket_qua_tx}** (T·ªïng: **{tong}**)\n\n"
                f"**D·ª± ƒëo√°n cho phi√™n ti·∫øp theo:**\n"
                f"üî¢ Phi√™n: `{next_expect}`\n"
                f"ü§ñ D·ª± ƒëo√°n: **{du_doan}**\n"
                f"üìå L√Ω do: _{ly_do}_\n"
                f"‚ö†Ô∏è **H√£y ƒë·∫∑t c∆∞·ª£c s·ªõm tr∆∞·ªõc khi phi√™n k·∫øt th√∫c!**"
            )

            # G·ª≠i tin nh·∫Øn d·ª± ƒëo√°n t·ªõi t·∫•t c·∫£ ng∆∞·ªùi d√πng c√≥ quy·ªÅn truy c·∫≠p v√† ƒëang nh·∫≠n d·ª± ƒëo√°n cho game n√†y
            for user_id_int in list(config['users_receiving']): 
                user_id_str = str(user_id_int)
                is_sub, sub_message = check_subscription(user_id_int)
                
                # Check if user opted to receive predictions for this specific game
                if user_id_str in user_data and user_data[user_id_str]['receiving_games'].get(game_name, False):
                    if is_sub:
                        # Allow Admin/Override users to receive even during maintenance
                        if config['maintenance_mode'] and not can_override_maintenance(user_id_int):
                            # print(f"DEBUG: Kh√¥ng g·ª≠i d·ª± ƒëo√°n cho user {user_id_str} v√¨ {game_name} ƒëang b·∫£o tr√¨ v√† kh√¥ng c√≥ quy·ªÅn override.")
                            continue

                        try:
                            bot.send_message(user_id_int, prediction_message, parse_mode='Markdown')
                            # print(f"DEBUG: ƒê√£ g·ª≠i d·ª± ƒëo√°n {game_name} cho user {user_id_str}")
                            sys.stdout.flush()
                        except telebot.apihelper.ApiTelegramException as e:
                            print(f"L·ªñI: L·ªói Telegram API khi g·ª≠i tin nh·∫Øn cho user {user_id_int} ({game_name}): {e}")
                            sys.stdout.flush()
                            if "bot was blocked by the user" in str(e) or "user is deactivated" in str(e):
                                print(f"C·∫¢NH B√ÅO: Ng∆∞·ªùi d√πng {user_id_int} ƒë√£ ch·∫∑n bot ho·∫∑c b·ªã v√¥ hi·ªáu h√≥a. X√≥a kh·ªèi danh s√°ch nh·∫≠n.")
                                config['users_receiving'].discard(user_id_int)
                                user_data[user_id_str]['receiving_games'][game_name] = False # Mark as not receiving
                                save_user_data(user_data)
                        except Exception as e:
                            print(f"L·ªñI: L·ªói kh√¥ng x√°c ƒë·ªãnh khi g·ª≠i tin nh·∫Øn cho user {user_id_int} ({game_name}): {e}")
                            sys.stdout.flush()
                    # else:
                        # print(f"DEBUG: Kh√¥ng g·ª≠i d·ª± ƒëo√°n {game_name} cho user {user_id_str} v√¨ h·∫øt h·∫°n/b·ªã c·∫•m.")

            print("-" * 50)
            print("LOG: {}: Phi√™n {} -> {}. K·∫øt qu·∫£: {} ({}). D·ª± ƒëo√°n: {}. L√Ω do: {}".format(config['game_name_vi'], expect, next_expect, ket_qua_tx, tong, du_doan, ly_do))
            print("-" * 50)
            sys.stdout.flush()

            last_id = issue_id

        time.sleep(5) # ƒê·ª£i 5 gi√¢y tr∆∞·ªõc khi ki·ªÉm tra phi√™n m·ªõi
    print(f"LOG: Lu·ªìng d·ª± ƒëo√°n cho {game_name} ƒë√£ d·ª´ng.")
    sys.stdout.flush()

# --- X·ª≠ l√Ω l·ªánh Telegram ---

@bot.message_handler(commands=['start'])
def send_welcome(message):
    user_id = str(message.chat.id)
    username = message.from_user.username or message.from_user.first_name
    
    if user_id not in user_data:
        user_data[user_id] = {
            'username': username,
            'expiry_date': None,
            'is_ctv': False,
            'banned': False,
            'ban_reason': None,
            'override_maintenance': False,
            'receiving_games': {game: True for game in GAME_CONFIGS.keys()} # M·∫∑c ƒë·ªãnh nh·∫≠n t·∫•t c·∫£
        }
        save_user_data(user_data)
        # Add user to all active game receiving lists
        for game_name, config in GAME_CONFIGS.items():
            config['users_receiving'].add(int(user_id))

        bot.reply_to(message, 
                     "Ch√†o m·ª´ng b·∫°n ƒë·∫øn v·ªõi **BOT D·ª∞ ƒêO√ÅN T√ÄI X·ªàU SUNWIN**!\n"
                     "H√£y d√πng l·ªánh /help ƒë·ªÉ xem danh s√°ch c√°c l·ªánh h·ªó tr·ª£.", 
                     parse_mode='Markdown')
    else:
        user_data[user_id]['username'] = username # C·∫≠p nh·∫≠t username n·∫øu c√≥ thay ƒë·ªïi
        # Ensure 'receiving_games' is initialized for existing users
        user_data[user_id].setdefault('receiving_games', {game: True for game in GAME_CONFIGS.keys()})
        # Add existing user to active game receiving lists if they are set to receive
        for game_name, config in GAME_CONFIGS.items():
            if user_data[user_id]['receiving_games'].get(game_name, False) and not user_data[user_id]['banned']:
                config['users_receiving'].add(int(user_id))

        save_user_data(user_data)
        bot.reply_to(message, "B·∫°n ƒë√£ kh·ªüi ƒë·ªông bot r·ªìi. D√πng /help ƒë·ªÉ xem c√°c l·ªánh.")

@bot.message_handler(commands=['help'])
def show_help(message):
    help_text = (
        "ü§ñ **DANH S√ÅCH L·ªÜNH H·ªñ TR·ª¢** ü§ñ\n\n"
        "**L·ªánh ng∆∞·ªùi d√πng:**\n"
        "üî∏ `/start`: Kh·ªüi ƒë·ªông bot v√† th√™m b·∫°n v√†o h·ªá th·ªëng.\n"
        "üî∏ `/help`: Hi·ªÉn th·ªã danh s√°ch c√°c l·ªánh.\n"
        "üî∏ `/support`: Th√¥ng tin h·ªó tr·ª£ Admin.\n"
        "üî∏ `/gia`: Xem b·∫£ng gi√° d·ªãch v·ª•.\n"
        "üî∏ `/gopy <n·ªôi dung>`: G·ª≠i g√≥p √Ω/b√°o l·ªói cho Admin.\n"
        "üî∏ `/nap`: H∆∞·ªõng d·∫´n n·∫°p ti·ªÅn.\n"
        "üî∏ `/dudoan`: B·∫Øt ƒë·∫ßu nh·∫≠n d·ª± ƒëo√°n cho Luckywin.\n"
        "üî∏ `/dudoan_hitclub`: B·∫Øt ƒë·∫ßu nh·∫≠n d·ª± ƒëo√°n cho Hit Club.\n"
        "üî∏ `/dudoan_sunwin`: B·∫Øt ƒë·∫ßu nh·∫≠n d·ª± ƒëo√°n cho Sunwin.\n"
        "üî∏ `/code <m√£_code>`: Nh·∫≠p m√£ code ƒë·ªÉ gia h·∫°n t√†i kho·∫£n.\n"
        "üî∏ `/stop [t√™n game]`: T·∫°m ng·ª´ng nh·∫≠n d·ª± ƒëo√°n (ƒë·ªÉ tr·ªëng ƒë·ªÉ t·∫°m ng·ª´ng t·∫•t c·∫£, ho·∫∑c ch·ªâ ƒë·ªãnh game).\n"
        "üî∏ `/continue [t√™n game]`: Ti·∫øp t·ª•c nh·∫≠n d·ª± ƒëo√°n (ƒë·ªÉ tr·ªëng ƒë·ªÉ ti·∫øp t·ª•c t·∫•t c·∫£, ho·∫∑c ch·ªâ ƒë·ªãnh game).\n\n"
    )
    
    if is_ctv(message.chat.id):
        help_text += (
            "**L·ªánh Admin/CTV:**\n"
            "üîπ `/full <id>`: Xem th√¥ng tin ng∆∞·ªùi d√πng (ƒë·ªÉ tr·ªëng ID ƒë·ªÉ xem c·ªßa b·∫°n).\n"
            "üîπ `/giahan <id> <s·ªë ng√†y/gi·ªù>`: Gia h·∫°n t√†i kho·∫£n ng∆∞·ªùi d√πng. V√≠ d·ª•: `/giahan 12345 1 ng√†y` ho·∫∑c `/giahan 12345 24 gi·ªù`.\n\n"
        )
    
    if is_admin(message.chat.id):
        help_text += (
            "**L·ªánh Admin Ch√≠nh:**\n"
            "üëë `/ctv <id>`: Th√™m ng∆∞·ªùi d√πng l√†m CTV.\n"
            "üëë `/xoactv <id>`: X√≥a ng∆∞·ªùi d√πng kh·ªèi CTV.\n"
            "üëë `/tb <n·ªôi dung>`: G·ª≠i th√¥ng b√°o ƒë·∫øn t·∫•t c·∫£ ng∆∞·ªùi d√πng.\n"
            "üëë `/tatbot <l√Ω do>`: T·∫Øt m·ªçi ho·∫°t ƒë·ªông c·ªßa bot d·ª± ƒëo√°n.\n"
            "üëë `/mokbot`: M·ªü l·∫°i ho·∫°t ƒë·ªông c·ªßa bot d·ª± ƒëo√°n.\n"
            "üëë `/taocode <gi√° tr·ªã> <ng√†y/gi·ªù> <s·ªë l∆∞·ª£ng>`: T·∫°o m√£ code gia h·∫°n. V√≠ d·ª•: `/taocode 1 ng√†y 5`.\n"
            "üëë `/maucau <t√™n game>`: Hi·ªÉn th·ªã c√°c m·∫´u c·∫ßu ƒë√£ thu th·∫≠p cho game.\n"
            "üëë `/kiemtra`: Ki·ªÉm tra th√¥ng tin t·∫•t c·∫£ ng∆∞·ªùi d√πng bot.\n"
            "üëë `/xoahan <id>`: X√≥a s·ªë ng√†y c√≤n l·∫°i c·ªßa ng∆∞·ªùi d√πng.\n"
            "üëë `/ban <id> [l√Ω do]`: C·∫•m ng∆∞·ªùi d√πng s·ª≠ d·ª•ng bot.\n"
            "üëë `/unban <id>`: B·ªè c·∫•m ng∆∞·ªùi d√πng.\n"
            "üëë `/baotri <t√™n game> [l√Ω do]`: ƒê·∫∑t game v√†o tr·∫°ng th√°i b·∫£o tr√¨.\n"
            "üëë `/mobaochi <t√™n game>`: B·ªè tr·∫°ng th√°i b·∫£o tr√¨ cho game.\n"
            "üëë `/override <id>`: C·∫•p quy·ªÅn Admin/CTV v·∫´n nh·∫≠n d·ª± ƒëo√°n khi game b·∫£o tr√¨.\n"
            "üëë `/unoverride <id>`: X√≥a quy·ªÅn Admin/CTV override b·∫£o tr√¨.\n"
            "üëë `/stats [t√™n game]`: Xem th·ªëng k√™ d·ª± ƒëo√°n c·ªßa bot.\n"
        )
    
    bot.reply_to(message, help_text, parse_mode='Markdown')

@bot.message_handler(commands=['support'])
def show_support(message):
    bot.reply_to(message, 
        "ƒê·ªÉ ƒë∆∞·ª£c h·ªó tr·ª£, vui l√≤ng li√™n h·ªá Admin:\n"
        "@heheviptool ho·∫∑c @Besttaixiu999"
    )

@bot.message_handler(commands=['gia'])
def show_price(message):
    price_text = (
        "üìä **BOT SUNWIN XIN TH√îNG B√ÅO B·∫¢NG GI√Å SUN BOT** üìä\n\n"
        "üí∏ **20k**: 1 Ng√†y\n"
        "üí∏ **50k**: 1 Tu·∫ßn\n"
        "üí∏ **80k**: 2 Tu·∫ßn\n"
        "üí∏ **130k**: 1 Th√°ng\n\n"
        "ü§ñ BOT SUN T·ªà L·ªá **85-92%**\n"
        "‚è±Ô∏è ƒê·ªåC 24/24\n\n"
        "Vui L√≤ng ib @heheviptool ho·∫∑c @Besttaixiu999 ƒê·ªÉ Gia H·∫°n"
    )
    bot.reply_to(message, price_text, parse_mode='Markdown')

@bot.message_handler(commands=['gopy'])
def send_feedback(message):
    feedback_text = telebot.util.extract_arguments(message.text)
    if not feedback_text:
        bot.reply_to(message, "Vui l√≤ng nh·∫≠p n·ªôi dung g√≥p √Ω. V√≠ d·ª•: `/gopy Bot d·ª± ƒëo√°n r·∫•t chu·∫©n!`", parse_mode='Markdown')
        return
    
    admin_id = ADMIN_IDS[0] # G·ª≠i cho Admin ƒë·∫ßu ti√™n trong danh s√°ch
    user_name = message.from_user.username or message.from_user.first_name
    bot.send_message(admin_id, 
                     f"üì¢ **G√ìP √ù M·ªöI T·ª™ NG∆Ø·ªúI D√ôNG** üì¢\n\n"
                     f"**ID:** `{message.chat.id}`\n"
                     f"**T√™n:** @{user_name}\n\n"
                     f"**N·ªôi dung:**\n`{feedback_text}`",
                     parse_mode='Markdown')
    bot.reply_to(message, "C·∫£m ∆°n b·∫°n ƒë√£ g·ª≠i g√≥p √Ω! Admin ƒë√£ nh·∫≠n ƒë∆∞·ª£c.")

@bot.message_handler(commands=['nap'])
def show_deposit_info(message):
    user_id = message.chat.id
    deposit_text = (
        "‚öúÔ∏è **N·∫†P TI·ªÄN MUA L∆Ø·ª¢T** ‚öúÔ∏è\n\n"
        "ƒê·ªÉ mua l∆∞·ª£t, vui l√≤ng chuy·ªÉn kho·∫£n ƒë·∫øn:\n"
        "- Ng√¢n h√†ng: **MB BANK**\n"
        "- S·ªë t√†i kho·∫£n: **0939766383**\n"
        "- T√™n ch·ªß TK: **Nguyen Huynh Nhut Quang**\n\n"
        "**N·ªòI DUNG CHUY·ªÇN KHO·∫¢N (QUAN TR·ªåNG):**\n"
        "`mua luot {user_id}`\n\n"
        f"‚ùóÔ∏è N·ªôi dung b·∫Øt bu·ªôc c·ªßa b·∫°n l√†:\n"
        f"`mua luot {user_id}`\n\n"
        "(Vui l√≤ng sao ch√©p ƒë√∫ng n·ªôi dung tr√™n ƒë·ªÉ ƒë∆∞·ª£c c·ªông l∆∞·ª£t t·ª± ƒë·ªông)\n"
        "Sau khi chuy·ªÉn kho·∫£n, vui l√≤ng ch·ªù 1-2 ph√∫t. N·∫øu c√≥ s·ª± c·ªë, h√£y d√πng l·ªánh /support."
    )
    bot.reply_to(message, deposit_text, parse_mode='Markdown')

# H√†m chung ƒë·ªÉ x·ª≠ l√Ω l·ªánh /dudoan_<game>
def handle_dudoan_command(message, game_name):
    user_id = message.chat.id
    user_id_str = str(user_id)
    
    is_sub, sub_message = check_subscription(user_id)
    
    if not is_sub:
        bot.reply_to(message, sub_message + "\nVui l√≤ng li√™n h·ªá Admin @heheviptool ho·∫∑c @Besttaixiu999 ƒë·ªÉ ƒë∆∞·ª£c h·ªó tr·ª£.", parse_mode='Markdown')
        return
    
    if not bot_enabled:
        bot.reply_to(message, f"‚ùå Bot d·ª± ƒëo√°n to√†n c·ª•c hi·ªán ƒëang t·∫°m d·ª´ng b·ªüi Admin. L√Ω do: `{bot_disable_reason}`", parse_mode='Markdown')
        return

    game_config = GAME_CONFIGS.get(game_name)
    if not game_config:
        bot.reply_to(message, "Game n√†y kh√¥ng ƒë∆∞·ª£c h·ªó tr·ª£.", parse_mode='Markdown')
        return

    if game_config['maintenance_mode'] and not can_override_maintenance(user_id):
        bot.reply_to(message, f"‚ùå Game **{game_config['game_name_vi']}** hi·ªán ƒëang b·∫£o tr√¨. L√Ω do: `{game_config['maintenance_reason']}`", parse_mode='Markdown')
        return
    
    if not game_config['prediction_enabled']:
        bot.reply_to(message, f"‚ùå D·ª± ƒëo√°n cho game **{game_config['game_name_vi']}** hi·ªán ƒëang t·∫°m d·ª´ng. Vui l√≤ng th·ª≠ l·∫°i sau.", parse_mode='Markdown')
        return

    # Update user's preference to receive this game's predictions
    if user_id_str not in user_data:
        # This case should ideally not happen if /start is used first
        user_data[user_id_str] = {'username': message.from_user.username or message.from_user.first_name, 'expiry_date': None, 'is_ctv': False, 'banned': False, 'ban_reason': None, 'override_maintenance': False, 'receiving_games': {game: False for game in GAME_CONFIGS.keys()}}
    
    user_data[user_id_str]['receiving_games'][game_name] = True
    GAME_CONFIGS[game_name]['users_receiving'].add(user_id)
    save_user_data(user_data)

    bot.reply_to(message, f"‚úÖ B·∫°n ƒëang c√≥ quy·ªÅn truy c·∫≠p v√† s·∫Ω nh·∫≠n d·ª± ƒëo√°n cho game **{game_config['game_name_vi']}**.")

@bot.message_handler(commands=['dudoan'])
def start_prediction_luckywin(message):
    handle_dudoan_command(message, 'luckywin')

@bot.message_handler(commands=['dudoan_hitclub'])
def start_prediction_hitclub(message):
    handle_dudoan_command(message, 'hitclub')

@bot.message_handler(commands=['dudoan_sunwin'])
def start_prediction_sunwin(message):
    handle_dudoan_command(message, 'sunwin')

@bot.message_handler(commands=['stop'])
def stop_receiving_predictions(message):
    user_id = message.chat.id
    user_id_str = str(user_id)
    args = telebot.util.extract_arguments(message.text).lower().split()
    
    if user_id_str not in user_data:
        bot.reply_to(message, "B·∫°n ch∆∞a kh·ªüi ƒë·ªông bot. Vui l√≤ng d√πng /start tr∆∞·ªõc.")
        return

    if not args: # Stop all games
        for game_name, config in GAME_CONFIGS.items():
            user_data[user_id_str]['receiving_games'][game_name] = False
            config['users_receiving'].discard(user_id)
        save_user_data(user_data)
        bot.reply_to(message, "ƒê√£ t·∫°m ng·ª´ng nh·∫≠n d·ª± ƒëo√°n cho **t·∫•t c·∫£ c√°c game**.", parse_mode='Markdown')
    else: # Stop specific game
        game_arg = args[0]
        matched_game = None
        for game_key, config in GAME_CONFIGS.items():
            if game_key == game_arg or config['game_name_vi'].lower().replace(" ", "") == game_arg.replace(" ", ""):
                matched_game = game_key
                break
        
        if matched_game:
            user_data[user_id_str]['receiving_games'][matched_game] = False
            GAME_CONFIGS[matched_game]['users_receiving'].discard(user_id)
            save_user_data(user_data)
            bot.reply_to(message, f"ƒê√£ t·∫°m ng·ª´ng nh·∫≠n d·ª± ƒëo√°n cho game **{GAME_CONFIGS[matched_game]['game_name_vi']}**.", parse_mode='Markdown')
        else:
            bot.reply_to(message, "T√™n game kh√¥ng h·ª£p l·ªá. C√°c game ƒë∆∞·ª£c h·ªó tr·ª£: Luckywin, Hit Club, Sunwin.", parse_mode='Markdown')

@bot.message_handler(commands=['continue'])
def continue_receiving_predictions(message):
    user_id = message.chat.id
    user_id_str = str(user_id)
    args = telebot.util.extract_arguments(message.text).lower().split()

    is_sub, sub_message = check_subscription(user_id)
    if not is_sub:
        bot.reply_to(message, sub_message + "\nVui l√≤ng li√™n h·ªá Admin ƒë·ªÉ ƒë∆∞·ª£c h·ªó tr·ª£.", parse_mode='Markdown')
        return

    if user_id_str not in user_data:
        bot.reply_to(message, "B·∫°n ch∆∞a kh·ªüi ƒë·ªông bot. Vui l√≤ng d√πng /start tr∆∞·ªõc.")
        return

    if not args: # Continue all games
        for game_name, config in GAME_CONFIGS.items():
            # Check for global bot enable and game maintenance
            if not bot_enabled:
                bot.reply_to(message, f"‚ùå Bot d·ª± ƒëo√°n to√†n c·ª•c hi·ªán ƒëang t·∫°m d·ª´ng b·ªüi Admin. L√Ω do: `{bot_disable_reason}`", parse_mode='Markdown')
                continue
            if config['maintenance_mode'] and not can_override_maintenance(user_id):
                bot.reply_to(message, f"‚ùå Game **{config['game_name_vi']}** hi·ªán ƒëang b·∫£o tr√¨. L√Ω do: `{config['maintenance_reason']}`", parse_mode='Markdown')
                continue
            if not config['prediction_enabled']:
                bot.reply_to(message, f"‚ùå D·ª± ƒëo√°n cho game **{config['game_name_vi']}** hi·ªán ƒëang t·∫°m d·ª´ng. Vui l√≤ng th·ª≠ l·∫°i sau.", parse_mode='Markdown')
                continue

            user_data[user_id_str]['receiving_games'][game_name] = True
            config['users_receiving'].add(user_id)
        save_user_data(user_data)
        bot.reply_to(message, "ƒê√£ ti·∫øp t·ª•c nh·∫≠n d·ª± ƒëo√°n cho **t·∫•t c·∫£ c√°c game** (n·∫øu game kh√¥ng b·∫£o tr√¨ v√† bot ho·∫°t ƒë·ªông).", parse_mode='Markdown')
    else: # Continue specific game
        game_arg = args[0]
        matched_game = None
        for game_key, config in GAME_CONFIGS.items():
            if game_key == game_arg or config['game_name_vi'].lower().replace(" ", "") == game_arg.replace(" ", ""):
                matched_game = game_key
                break
        
        if matched_game:
            game_config = GAME_CONFIGS[matched_game]
            if not bot_enabled:
                bot.reply_to(message, f"‚ùå Bot d·ª± ƒëo√°n to√†n c·ª•c hi·ªán ƒëang t·∫°m d·ª´ng b·ªüi Admin. L√Ω do: `{bot_disable_reason}`", parse_mode='Markdown')
                return
            if game_config['maintenance_mode'] and not can_override_maintenance(user_id):
                bot.reply_to(message, f"‚ùå Game **{game_config['game_name_vi']}** hi·ªán ƒëang b·∫£o tr√¨. L√Ω do: `{game_config['maintenance_reason']}`", parse_mode='Markdown')
                return
            if not game_config['prediction_enabled']:
                bot.reply_to(message, f"‚ùå D·ª± ƒëo√°n cho game **{game_config['game_name_vi']}** hi·ªán ƒëang t·∫°m d·ª´ng. Vui l√≤ng th·ª≠ l·∫°i sau.", parse_mode='Markdown')
                return

            user_data[user_id_str]['receiving_games'][matched_game] = True
            game_config['users_receiving'].add(user_id)
            save_user_data(user_data)
            bot.reply_to(message, f"ƒê√£ ti·∫øp t·ª•c nh·∫≠n d·ª± ƒëo√°n cho game **{game_config['game_name_vi']}**.", parse_mode='Markdown')
        else:
            bot.reply_to(message, "T√™n game kh√¥ng h·ª£p l·ªá. C√°c game ƒë∆∞·ª£c h·ªó tr·ª£: Luckywin, Hit Club, Sunwin.", parse_mode='Markdown')

@bot.message_handler(commands=['maucau'])
def show_cau_patterns_command(message):
    if not is_admin(message.chat.id): # Ch·ªâ Admin m·ªõi ƒë∆∞·ª£c xem m·∫´u c·∫ßu chi ti·∫øt
        bot.reply_to(message, "B·∫°n kh√¥ng c√≥ quy·ªÅn s·ª≠ d·ª•ng l·ªánh n√†y.")
        return

    args = telebot.util.extract_arguments(message.text).lower().split()
    if not args:
        bot.reply_to(message, "Vui l√≤ng ch·ªâ ƒë·ªãnh t√™n game ƒë·ªÉ xem m·∫´u c·∫ßu. V√≠ d·ª•: `/maucau luckywin`", parse_mode='Markdown')
        return
    
    game_arg = args[0]
    matched_game = None
    for game_key, config in GAME_CONFIGS.items():
        if game_key == game_arg or config['game_name_vi'].lower().replace(" ", "") == game_arg.replace(" ", ""):
            matched_game = game_key
            break
    
    if not matched_game:
        bot.reply_to(message, "T√™n game kh√¥ng h·ª£p l·ªá. C√°c game ƒë∆∞·ª£c h·ªó tr·ª£: Luckywin, Hit Club, Sunwin.", parse_mode='Markdown')
        return

    dep_patterns = "\n".join(sorted(list(CAU_DEP.get(matched_game, set())))) if CAU_DEP.get(matched_game) else "Kh√¥ng c√≥"
    xau_patterns = "\n".join(sorted(list(CAU_XAU.get(matched_game, set())))) if CAU_XAU.get(matched_game) else "Kh√¥ng c√≥"

    pattern_text = (
        f"üìö **C√ÅC M·∫™U C·∫¶U ƒê√É THU TH·∫¨P CHO {GAME_CONFIGS[matched_game]['game_name_vi'].upper()}** üìö\n\n"
        "**üü¢ C·∫ßu ƒê·∫πp:**\n"
        f"```\n{dep_patterns}\n```\n\n"
        "**üî¥ C·∫ßu X·∫•u:**\n"
        f"```\n{xau_patterns}\n```\n"
        "*(C√°c m·∫´u c·∫ßu n√†y ƒë∆∞·ª£c bot t·ª± ƒë·ªông h·ªçc h·ªèi theo th·ªùi gian.)*"
    )
    bot.reply_to(message, pattern_text, parse_mode='Markdown')

@bot.message_handler(commands=['code'])
def use_code(message):
    code_str = telebot.util.extract_arguments(message.text)
    user_id = str(message.chat.id)

    if not code_str:
        bot.reply_to(message, "Vui l√≤ng nh·∫≠p m√£ code. V√≠ d·ª•: `/code ABCXYZ`", parse_mode='Markdown')
        return
    
    if code_str not in GENERATED_CODES:
        bot.reply_to(message, "‚ùå M√£ code kh√¥ng t·ªìn t·∫°i ho·∫∑c ƒë√£ h·∫øt h·∫°n.")
        return

    code_info = GENERATED_CODES[code_str]
    if code_info.get('used_by') is not None:
        bot.reply_to(message, "‚ùå M√£ code n√†y ƒë√£ ƒë∆∞·ª£c s·ª≠ d·ª•ng r·ªìi.")
        return

    # Apply extension
    current_expiry_str = user_data.get(user_id, {}).get('expiry_date')
    if current_expiry_str:
        current_expiry_date = datetime.strptime(current_expiry_str, '%Y-%m-%d %H:%M:%S')
        # If current expiry is in the past, start from now
        if datetime.now() > current_expiry_date:
            new_expiry_date = datetime.now()
        else:
            new_expiry_date = current_expiry_date
    else:
        new_expiry_date = datetime.now() # Start from now if no previous expiry

    value = code_info['value']
    if code_info['type'] == 'ng√†y':
        new_expiry_date += timedelta(days=value)
    elif code_info['type'] == 'gi·ªù':
        new_expiry_date += timedelta(hours=value)
    
    user_data.setdefault(user_id, {})['expiry_date'] = new_expiry_date.strftime('%Y-%m-%d %H:%M:%S')
    user_data[user_id]['username'] = message.from_user.username or message.from_user.first_name
    # Ensure 'receiving_games' is initialized for this user
    user_data[user_id].setdefault('receiving_games', {game: True for game in GAME_CONFIGS.keys()})
    
    GENERATED_CODES[code_str]['used_by'] = user_id
    GENERATED_CODES[code_str]['used_time'] = datetime.now().strftime('%Y-%m-%d %H:%M:%S')

    save_user_data(user_data)
    save_codes()

    bot.reply_to(message, 
                 f"üéâ B·∫°n ƒë√£ ƒë·ªïi m√£ code th√†nh c√¥ng! T√†i kho·∫£n c·ªßa b·∫°n ƒë√£ ƒë∆∞·ª£c gia h·∫°n th√™m **{value} {code_info['type']}**.\n"
                 f"Ng√†y h·∫øt h·∫°n m·ªõi: `{user_data[user_id]['expiry_date']}`", 
                 parse_mode='Markdown')

def user_expiry_date(user_id):
    if str(user_id) in user_data and user_data[str(user_id)].get('expiry_date'):
        return user_data[str(user_id)]['expiry_date']
    return "Kh√¥ng c√≥"

# --- L·ªánh Admin/CTV ---
@bot.message_handler(commands=['full'])
def get_user_info(message):
    if not is_ctv(message.chat.id):
        bot.reply_to(message, "B·∫°n kh√¥ng c√≥ quy·ªÅn s·ª≠ d·ª•ng l·ªánh n√†y.")
        return
    
    args = telebot.util.extract_arguments(message.text).split()
    target_user_id_str = str(message.chat.id)
    if args and args[0].isdigit():
        target_user_id_str = args[0]
    
    if target_user_id_str not in user_data:
        bot.reply_to(message, f"Kh√¥ng t√¨m th·∫•y th√¥ng tin cho ng∆∞·ªùi d√πng ID `{target_user_id_str}`.")
        return

    user_info = user_data[target_user_id_str]
    expiry_date_str = user_info.get('expiry_date', 'Kh√¥ng c√≥')
    username = user_info.get('username', 'Kh√¥ng r√µ')
    is_ctv_status = "C√≥" if is_ctv(int(target_user_id_str)) else "Kh√¥ng"
    banned_status = "C√≥" if user_info.get('banned') else "Kh√¥ng"
    ban_reason = f"L√Ω do: `{user_info.get('ban_reason')}`" if user_info.get('banned') and user_info.get('ban_reason') else ""
    override_status = "C√≥" if user_info.get('override_maintenance') else "Kh√¥ng"

    receiving_games_status = []
    for game_name, is_receiving in user_info.get('receiving_games', {}).items():
        receiving_games_status.append(f"{GAME_CONFIGS[game_name]['game_name_vi']}: {'‚úÖ' if is_receiving else '‚ùå'}")
    receiving_games_text = "\n".join(receiving_games_status) if receiving_games_status else "Kh√¥ng c√†i ƒë·∫∑t"


    info_text = (
        f"**TH√îNG TIN NG∆Ø·ªúI D√ôNG**\n"
        f"**ID:** `{target_user_id_str}`\n"
        f"**T√™n:** @{username}\n"
        f"**Ng√†y h·∫øt h·∫°n:** `{expiry_date_str}`\n"
        f"**L√† CTV/Admin:** {is_ctv_status}\n"
        f"**B·ªã c·∫•m:** {banned_status} {ban_reason}\n"
        f"**Override B·∫£o tr√¨:** {override_status}\n"
        f"**Nh·∫≠n d·ª± ƒëo√°n cho:**\n{receiving_games_text}"
    )
    bot.reply_to(message, info_text, parse_mode='Markdown')

@bot.message_handler(commands=['giahan'])
def extend_subscription(message):
    if not is_ctv(message.chat.id):
        bot.reply_to(message, "B·∫°n kh√¥ng c√≥ quy·ªÅn s·ª≠ d·ª•ng l·ªánh n√†y.")
        return
    
    args = telebot.util.extract_arguments(message.text).split()
    if len(args) != 3 or not args[0].isdigit() or not args[1].isdigit() or args[2].lower() not in ['ng√†y', 'gi·ªù']:
        bot.reply_to(message, "C√∫ ph√°p sai. V√≠ d·ª•: `/giahan <id_nguoi_dung> <s·ªë_l∆∞·ª£ng> <ng√†y/gi·ªù>`\n"
                              "V√≠ d·ª•: `/giahan 12345 1 ng√†y` ho·∫∑c `/giahan 12345 24 gi·ªù`", parse_mode='Markdown')
        return
    
    target_user_id_str = args[0]
    value = int(args[1])
    unit = args[2].lower() # 'ng√†y' or 'gi·ªù'
    
    if target_user_id_str not in user_data:
        user_data[target_user_id_str] = {
            'username': "UnknownUser",
            'expiry_date': None,
            'is_ctv': False,
            'banned': False,
            'ban_reason': None,
            'override_maintenance': False,
            'receiving_games': {game: True for game in GAME_CONFIGS.keys()}
        }
        bot.send_message(message.chat.id, f"ƒê√£ t·∫°o t√†i kho·∫£n m·ªõi cho user ID `{target_user_id_str}`.")
        # Add to all game receiving lists by default
        for game_name, config in GAME_CONFIGS.items():
            config['users_receiving'].add(int(target_user_id_str))

    current_expiry_str = user_data[target_user_id_str].get('expiry_date')
    if current_expiry_str:
        current_expiry_date = datetime.strptime(current_expiry_str, '%Y-%m-%d %H:%M:%S')
        if datetime.now() > current_expiry_date:
            new_expiry_date = datetime.now()
        else:
            new_expiry_date = current_expiry_date
    else:
        new_expiry_date = datetime.now() # Start from now if no previous expiry

    if unit == 'ng√†y':
        new_expiry_date += timedelta(days=value)
    elif unit == 'gi·ªù':
        new_expiry_date += timedelta(hours=value)
    
    user_data[target_user_id_str]['expiry_date'] = new_expiry_date.strftime('%Y-%m-%d %H:%M:%S')
    save_user_data(user_data)
    
    bot.reply_to(message, 
                 f"ƒê√£ gia h·∫°n th√†nh c√¥ng cho user ID `{target_user_id_str}` th√™m **{value} {unit}**.\n"
                 f"Ng√†y h·∫øt h·∫°n m·ªõi: `{user_data[target_user_id_str]['expiry_date']}`",
                 parse_mode='Markdown')
    
    try:
        bot.send_message(int(target_user_id_str), 
                         f"üéâ T√†i kho·∫£n c·ªßa b·∫°n ƒë√£ ƒë∆∞·ª£c gia h·∫°n th√™m **{value} {unit}** b·ªüi Admin/CTV!\n"
                         f"Ng√†y h·∫øt h·∫°n m·ªõi c·ªßa b·∫°n l√†: `{user_data[target_user_id_str]['expiry_date']}`",
                         parse_mode='Markdown')
    except telebot.apihelper.ApiTelegramException as e:
        if "bot was blocked by the user" in str(e):
            print(f"C·∫¢NH B√ÅO: Kh√¥ng th·ªÉ th√¥ng b√°o gia h·∫°n cho user {target_user_id_str}: Ng∆∞·ªùi d√πng ƒë√£ ch·∫∑n bot.")
        else:
            print(f"L·ªñI: Kh√¥ng th·ªÉ th√¥ng b√°o gia h·∫°n cho user {target_user_id_str}: {e}")
        sys.stdout.flush()

# --- L·ªánh Admin Ch√≠nh ---
@bot.message_handler(commands=['ctv'])
def add_ctv(message):
    if not is_admin(message.chat.id):
        bot.reply_to(message, "B·∫°n kh√¥ng c√≥ quy·ªÅn s·ª≠ d·ª•ng l·ªánh n√†y.")
        return
    
    args = telebot.util.extract_arguments(message.text).split()
    if not args or not args[0].isdigit():
        bot.reply_to(message, "C√∫ ph√°p sai. V√≠ d·ª•: `/ctv <id_nguoi_dung>`", parse_mode='Markdown')
        return
    
    target_user_id_str = args[0]
    if target_user_id_str not in user_data:
        user_data[target_user_id_str] = {
            'username': "UnknownUser",
            'expiry_date': None,
            'is_ctv': True,
            'banned': False,
            'ban_reason': None,
            'override_maintenance': False,
            'receiving_games': {game: True for game in GAME_CONFIGS.keys()}
        }
    else:
        user_data[target_user_id_str]['is_ctv'] = True
    
    save_user_data(user_data)
    bot.reply_to(message, f"ƒê√£ c·∫•p quy·ªÅn CTV cho user ID `{target_user_id_str}`.")
    try:
        bot.send_message(int(target_user_id_str), "üéâ B·∫°n ƒë√£ ƒë∆∞·ª£c c·∫•p quy·ªÅn CTV!")
    except Exception:
        pass

@bot.message_handler(commands=['xoactv'])
def remove_ctv(message):
    if not is_admin(message.chat.id):
        bot.reply_to(message, "B·∫°n kh√¥ng c√≥ quy·ªÅn s·ª≠ d·ª•ng l·ªánh n√†y.")
        return
    
    args = telebot.util.extract_arguments(message.text).split()
    if not args or not args[0].isdigit():
        bot.reply_to(message, "C√∫ ph√°p sai. V√≠ d·ª•: `/xoactv <id_nguoi_dung>`", parse_mode='Markdown')
        return
    
    target_user_id_str = args[0]
    if target_user_id_str in user_data:
        user_data[target_user_id_str]['is_ctv'] = False
        save_user_data(user_data)
        bot.reply_to(message, f"ƒê√£ x√≥a quy·ªÅn CTV c·ªßa user ID `{target_user_id_str}`.")
        try:
            bot.send_message(int(target_user_id_str), "‚ùå Quy·ªÅn CTV c·ªßa b·∫°n ƒë√£ b·ªã g·ª° b·ªè.")
        except Exception:
            pass
    else:
        bot.reply_to(message, f"Kh√¥ng t√¨m th·∫•y ng∆∞·ªùi d√πng c√≥ ID `{target_user_id_str}`.")

@bot.message_handler(commands=['tb'])
def send_broadcast(message):
    if not is_admin(message.chat.id):
        bot.reply_to(message, "B·∫°n kh√¥ng c√≥ quy·ªÅn s·ª≠ d·ª•ng l·ªánh n√†y.")
        return
    
    broadcast_text = telebot.util.extract_arguments(message.text)
    if not broadcast_text:
        bot.reply_to(message, "Vui l√≤ng nh·∫≠p n·ªôi dung th√¥ng b√°o. V√≠ d·ª•: `/tb Bot s·∫Ω b·∫£o tr√¨ v√†o 2h s√°ng mai.`", parse_mode='Markdown')
        return
    
    success_count = 0
    fail_count = 0
    for user_id_str in list(user_data.keys()):
        try:
            bot.send_message(int(user_id_str), f"üì¢ **TH√îNG B√ÅO T·ª™ ADMIN** üì¢\n\n{broadcast_text}", parse_mode='Markdown')
            success_count += 1
            time.sleep(0.1) # Tr√°nh b·ªã rate limit
        except telebot.apihelper.ApiTelegramException as e:
            print(f"L·ªñI: Kh√¥ng th·ªÉ g·ª≠i th√¥ng b√°o cho user {user_id_str}: {e}")
            sys.stdout.flush()
            fail_count += 1
            if "bot was blocked by the user" in str(e) or "user is deactivated" in str(e):
                print(f"C·∫¢NH B√ÅO: Ng∆∞·ªùi d√πng {user_id_str} ƒë√£ ch·∫∑n bot ho·∫∑c b·ªã v√¥ hi·ªáu h√≥a. ƒêang x√≥a ng∆∞·ªùi d√πng kh·ªèi danh s√°ch nh·∫≠n.")
                # Remove user from all receiving lists
                for game_name, config in GAME_CONFIGS.items():
                    config['users_receiving'].discard(int(user_id_str))
                if user_id_str in user_data:
                    del user_data[user_id_str] # Remove completely
                    save_user_data(user_data) # Save immediately
        except Exception as e:
            print(f"L·ªñI: L·ªói kh√¥ng x√°c ƒë·ªãnh khi g·ª≠i th√¥ng b√°o cho user {user_id_str}: {e}")
            sys.stdout.flush()
            fail_count += 1
            
    bot.reply_to(message, f"ƒê√£ g·ª≠i th√¥ng b√°o ƒë·∫øn {success_count} ng∆∞·ªùi d√πng. Th·∫•t b·∫°i: {fail_count}.")

@bot.message_handler(commands=['tatbot'])
def disable_bot_command(message):
    global bot_enabled, bot_disable_reason, bot_disable_admin_id
    if not is_admin(message.chat.id):
        bot.reply_to(message, "B·∫°n kh√¥ng c√≥ quy·ªÅn s·ª≠ d·ª•ng l·ªánh n√†y.")
        return

    reason = telebot.util.extract_arguments(message.text)
    if not reason:
        bot.reply_to(message, "Vui l√≤ng nh·∫≠p l√Ω do t·∫Øt bot. V√≠ d·ª•: `/tatbot Bot ƒëang b·∫£o tr√¨.`", parse_mode='Markdown')
        return

    bot_enabled = False
    bot_disable_reason = reason
    bot_disable_admin_id = message.chat.id
    save_bot_status() # Save bot status
    bot.reply_to(message, f"‚úÖ Bot d·ª± ƒëo√°n ƒë√£ ƒë∆∞·ª£c t·∫Øt b·ªüi Admin `{message.from_user.username or message.from_user.first_name}`.\nL√Ω do: `{reason}`", parse_mode='Markdown')
    sys.stdout.flush()
    
    # Optionally notify all users
    for user_id_str in list(user_data.keys()):
        try:
            bot.send_message(int(user_id_str), f"üì¢ **TH√îNG B√ÅO QUAN TR·ªåNG:** Bot d·ª± ƒëo√°n to√†n b·ªô t·∫°m th·ªùi d·ª´ng ho·∫°t ƒë·ªông.\nL√Ω do: {reason}\nVui l√≤ng ch·ªù th√¥ng b√°o m·ªü l·∫°i.", parse_mode='Markdown')
        except Exception:
            pass

@bot.message_handler(commands=['mokbot'])
def enable_bot_command(message):
    global bot_enabled, bot_disable_reason, bot_disable_admin_id
    if not is_admin(message.chat.id):
        bot.reply_to(message, "B·∫°n kh√¥ng c√≥ quy·ªÅn s·ª≠ d·ª•ng l·ªánh n√†y.")
        return

    if bot_enabled:
        bot.reply_to(message, "Bot d·ª± ƒëo√°n ƒë√£ v√† ƒëang ho·∫°t ƒë·ªông r·ªìi.")
        return

    bot_enabled = True
    bot_disable_reason = "Kh√¥ng c√≥"
    bot_disable_admin_id = None
    save_bot_status() # Save bot status
    bot.reply_to(message, "‚úÖ Bot d·ª± ƒëo√°n ƒë√£ ƒë∆∞·ª£c m·ªü l·∫°i b·ªüi Admin.")
    sys.stdout.flush()
    
    # Optionally notify all users
    for user_id_str in list(user_data.keys()):
        try:
            bot.send_message(int(user_id_str), "üéâ **TH√îNG B√ÅO:** Bot d·ª± ƒëo√°n to√†n b·ªô ƒë√£ ho·∫°t ƒë·ªông tr·ªü l·∫°i!.", parse_mode='Markdown')
        except Exception:
            pass

@bot.message_handler(commands=['taocode'])
def generate_code_command(message):
    if not is_admin(message.chat.id):
        bot.reply_to(message, "B·∫°n kh√¥ng c√≥ quy·ªÅn s·ª≠ d·ª•ng l·ªánh n√†y.")
        return
    
    args = telebot.util.extract_arguments(message.text).split()
    if len(args) < 2 or len(args) > 3: # Gi√° tr·ªã, ƒë∆°n v·ªã, s·ªë l∆∞·ª£ng (t√πy ch·ªçn)
        bot.reply_to(message, "C√∫ ph√°p sai. V√≠ d·ª•:\n"
                              "`/taocode <gi√°_tr·ªã> <ng√†y/gi·ªù> <s·ªë_l∆∞·ª£ng>`\n"
                              "V√≠ d·ª•: `/taocode 1 ng√†y 5` (t·∫°o 5 code 1 ng√†y)\n"
                              "Ho·∫∑c: `/taocode 24 gi·ªù` (t·∫°o 1 code 24 gi·ªù)", parse_mode='Markdown')
        return
    
    try:
        value = int(args[0])
        unit = args[1].lower()
        quantity = int(args[2]) if len(args) == 3 else 1 # M·∫∑c ƒë·ªãnh t·∫°o 1 code n·∫øu kh√¥ng c√≥ s·ªë l∆∞·ª£ng
        
        if unit not in ['ng√†y', 'gi·ªù']:
            bot.reply_to(message, "ƒê∆°n v·ªã kh√¥ng h·ª£p l·ªá. Ch·ªâ ch·∫•p nh·∫≠n `ng√†y` ho·∫∑c `gi·ªù`.", parse_mode='Markdown')
            return
        if value <= 0 or quantity <= 0:
            bot.reply_to(message, "Gi√° tr·ªã ho·∫∑c s·ªë l∆∞·ª£ng ph·∫£i l·ªõn h∆°n 0.", parse_mode='Markdown')
            return

        generated_codes_list = []
        for _ in range(quantity):
            new_code = ''.join(random.choices(string.ascii_uppercase + string.digits, k=8)) # 8 k√Ω t·ª± ng·∫´u nhi√™n
            GENERATED_CODES[new_code] = {
                "value": value,
                "type": unit,
                "used_by": None,
                "used_time": None
            }
            generated_codes_list.append(new_code)
        
        save_codes()
        
        response_text = f"‚úÖ ƒê√£ t·∫°o th√†nh c√¥ng {quantity} m√£ code gia h·∫°n **{value} {unit}**:\n\n"
        response_text += "\n".join([f"`{code}`" for code in generated_codes_list])
        response_text += "\n\n_(C√°c m√£ n√†y ch∆∞a ƒë∆∞·ª£c s·ª≠ d·ª•ng)_"
        
        bot.reply_to(message, response_text, parse_mode='Markdown')

    except ValueError:
        bot.reply_to(message, "Gi√° tr·ªã ho·∫∑c s·ªë l∆∞·ª£ng kh√¥ng h·ª£p l·ªá. Vui l√≤ng nh·∫≠p s·ªë nguy√™n.", parse_mode='Markdown')
    except Exception as e:
        bot.reply_to(message, f"ƒê√£ x·∫£y ra l·ªói khi t·∫°o code: {e}", parse_mode='Markdown')

@bot.message_handler(commands=['kiemtra'])
def check_all_users(message):
    if not is_admin(message.chat.id):
        bot.reply_to(message, "B·∫°n kh√¥ng c√≥ quy·ªÅn s·ª≠ d·ª•ng l·ªánh n√†y.")
        return
    
    if not user_data:
        bot.reply_to(message, "Ch∆∞a c√≥ ng∆∞·ªùi d√πng n√†o trong h·ªá th·ªëng.")
        return

    response_parts = ["üìã **TH√îNG TIN T·∫§T C·∫¢ NG∆Ø·ªúI D√ôNG** üìã\n"]
    for user_id_str, user_info in user_data.items():
        expiry_date_str = user_info.get('expiry_date', 'Kh√¥ng c√≥')
        username = user_info.get('username', 'Kh√¥ng r√µ')
        is_ctv_status = "CTV" if user_info.get('is_ctv') else "User"
        banned_status = "üö´ Banned" if user_info.get('banned') else ""
        
        response_parts.append(f"‚Ä¢ ID: `{user_id_str}` | T√™n: @{username} | H·∫°n: `{expiry_date_str}` | Quy·ªÅn: {is_ctv_status} {banned_status}")
        
        # Telegram message limit is 4096 characters, split if too long
        if len("\n".join(response_parts)) > 3500: # Leave some buffer
            bot.send_message(message.chat.id, "\n".join(response_parts), parse_mode='Markdown')
            response_parts = [] # Reset for next part
    
    if response_parts: # Send any remaining parts
        bot.send_message(message.chat.id, "\n".join(response_parts), parse_mode='Markdown')

@bot.message_handler(commands=['xoahan'])
def clear_expiry(message):
    if not is_admin(message.chat.id):
        bot.reply_to(message, "B·∫°n kh√¥ng c√≥ quy·ªÅn s·ª≠ d·ª•ng l·ªánh n√†y.")
        return
    
    args = telebot.util.extract_arguments(message.text).split()
    if not args or not args[0].isdigit():
        bot.reply_to(message, "C√∫ ph√°p sai. V√≠ d·ª•: `/xoahan <id_nguoi_dung>`", parse_mode='Markdown')
        return
    
    target_user_id_str = args[0]
    if target_user_id_str in user_data:
        user_data[target_user_id_str]['expiry_date'] = None
        save_user_data(user_data)
        bot.reply_to(message, f"ƒê√£ x√≥a h·∫°n s·ª≠ d·ª•ng c·ªßa user ID `{target_user_id_str}`.")
        try:
            bot.send_message(int(target_user_id_str), "‚ùå H·∫°n s·ª≠ d·ª•ng t√†i kho·∫£n c·ªßa b·∫°n ƒë√£ b·ªã x√≥a b·ªüi Admin.")
        except Exception:
            pass
    else:
        bot.reply_to(message, f"Kh√¥ng t√¨m th·∫•y ng∆∞·ªùi d√πng c√≥ ID `{target_user_id_str}`.")

@bot.message_handler(commands=['ban'])
def ban_user(message):
    if not is_admin(message.chat.id):
        bot.reply_to(message, "B·∫°n kh√¥ng c√≥ quy·ªÅn s·ª≠ d·ª•ng l·ªánh n√†y.")
        return
    
    args = telebot.util.extract_arguments(message.text).split()
    if not args or not args[0].isdigit():
        bot.reply_to(message, "C√∫ ph√°p sai. V√≠ d·ª•: `/ban <id_nguoi_dung> [l√Ω do]`", parse_mode='Markdown')
        return
    
    target_user_id_str = args[0]
    reason = " ".join(args[1:]) if len(args) > 1 else "Kh√¥ng c√≥ l√Ω do c·ª• th·ªÉ."

    if target_user_id_str not in user_data:
        user_data[target_user_id_str] = {
            'username': "UnknownUser",
            'expiry_date': None,
            'is_ctv': False,
            'banned': True,
            'ban_reason': reason,
            'override_maintenance': False,
            'receiving_games': {game: False for game in GAME_CONFIGS.keys()} # B·ªã ban th√¨ kh√¥ng nh·∫≠n d·ª± ƒëo√°n
        }
    else:
        user_data[target_user_id_str]['banned'] = True
        user_data[target_user_id_str]['ban_reason'] = reason
        # Also stop them from receiving any predictions
        for game_name, config in GAME_CONFIGS.items():
            user_data[target_user_id_str]['receiving_games'][game_name] = False
            config['users_receiving'].discard(int(target_user_id_str))
    
    save_user_data(user_data)
    bot.reply_to(message, f"ƒê√£ c·∫•m user ID `{target_user_id_str}`. L√Ω do: `{reason}`", parse_mode='Markdown')
    try:
        bot.send_message(int(target_user_id_str), f"üö´ T√†i kho·∫£n c·ªßa b·∫°n ƒë√£ b·ªã c·∫•m s·ª≠ d·ª•ng bot b·ªüi Admin. L√Ω do: `{reason}`")
    except Exception:
        pass

@bot.message_handler(commands=['unban'])
def unban_user(message):
    if not is_admin(message.chat.id):
        bot.reply_to(message, "B·∫°n kh√¥ng c√≥ quy·ªÅn s·ª≠ d·ª•ng l·ªánh n√†y.")
        return
    
    args = telebot.util.extract_arguments(message.text).split()
    if not args or not args[0].isdigit():
        bot.reply_to(message, "C√∫ ph√°p sai. V√≠ d·ª•: `/unban <id_nguoi_dung>`", parse_mode='Markdown')
        return
    
    target_user_id_str = args[0]
    if target_user_id_str in user_data:
        user_data[target_user_id_str]['banned'] = False
        user_data[target_user_id_str]['ban_reason'] = None
        # User is unbanned, let them receive predictions for games they previously opted for
        for game_name, config in GAME_CONFIGS.items():
             if user_data[target_user_id_str]['receiving_games'].get(game_name, False): # Only re-add if they were set to receive before
                config['users_receiving'].add(int(target_user_id_str))

        save_user_data(user_data)
        bot.reply_to(message, f"ƒê√£ b·ªè c·∫•m user ID `{target_user_id_str}`.")
        try:
            bot.send_message(int(target_user_id_str), "‚úÖ T√†i kho·∫£n c·ªßa b·∫°n ƒë√£ ƒë∆∞·ª£c b·ªè c·∫•m.")
        except Exception:
            pass
    else:
        bot.reply_to(message, f"Kh√¥ng t√¨m th·∫•y ng∆∞·ªùi d√πng c√≥ ID `{target_user_id_str}`.")

@bot.message_handler(commands=['baotri'])
def set_game_maintenance(message):
    if not is_admin(message.chat.id):
        bot.reply_to(message, "B·∫°n kh√¥ng c√≥ quy·ªÅn s·ª≠ d·ª•ng l·ªánh n√†y.")
        return
    
    args = telebot.util.extract_arguments(message.text).split(maxsplit=1) # Split only once to get reason
    if len(args) < 1:
        bot.reply_to(message, "C√∫ ph√°p sai. V√≠ d·ª•: `/baotri <t√™n_game> [l√Ω do]`", parse_mode='Markdown')
        return
    
    game_arg = args[0].lower()
    reason = args[1] if len(args) > 1 else "Bot ƒëang b·∫£o tr√¨ ƒë·ªÉ n√¢ng c·∫•p."

    matched_game = None
    for game_key, config in GAME_CONFIGS.items():
        if game_key == game_arg or config['game_name_vi'].lower().replace(" ", "") == game_arg.replace(" ", ""):
            matched_game = game_key
            break
    
    if not matched_game:
        bot.reply_to(message, "T√™n game kh√¥ng h·ª£p l·ªá. C√°c game ƒë∆∞·ª£c h·ªó tr·ª£: Luckywin, Hit Club, Sunwin.", parse_mode='Markdown')
        return

    GAME_CONFIGS[matched_game]['maintenance_mode'] = True
    GAME_CONFIGS[matched_game]['maintenance_reason'] = reason
    save_bot_status() # Save game status

    bot.reply_to(message, f"‚úÖ ƒê√£ ƒë·∫∑t game **{GAME_CONFIGS[matched_game]['game_name_vi']}** v√†o tr·∫°ng th√°i b·∫£o tr√¨.\nL√Ω do: `{reason}`", parse_mode='Markdown')
    
    # Notify all users receiving predictions for this game (who don't have override)
    for user_id_int in list(GAME_CONFIGS[matched_game]['users_receiving']):
        if not can_override_maintenance(user_id_int):
            try:
                bot.send_message(user_id_int, 
                                 f"üì¢ **TH√îNG B√ÅO B·∫¢O TR√å:** Game **{GAME_CONFIGS[matched_game]['game_name_vi']}** t·∫°m th·ªùi d·ª´ng d·ª± ƒëo√°n.\nL√Ω do: `{reason}`\nVui l√≤ng ch·ªù th√¥ng b√°o m·ªü l·∫°i.", 
                                 parse_mode='Markdown')
            except Exception:
                pass

@bot.message_handler(commands=['mobaochi'])
def unset_game_maintenance(message):
    if not is_admin(message.chat.id):
        bot.reply_to(message, "B·∫°n kh√¥ng c√≥ quy·ªÅn s·ª≠ d·ª•ng l·ªánh n√†y.")
        return
    
    args = telebot.util.extract_arguments(message.text).split()
    if len(args) < 1:
        bot.reply_to(message, "C√∫ ph√°p sai. V√≠ d·ª•: `/mobaochi <t√™n_game>`", parse_mode='Markdown')
        return
    
    game_arg = args[0].lower()
    matched_game = None
    for game_key, config in GAME_CONFIGS.items():
        if game_key == game_arg or config['game_name_vi'].lower().replace(" ", "") == game_arg.replace(" ", ""):
            matched_game = game_key
            break
    
    if not matched_game:
        bot.reply_to(message, "T√™n game kh√¥ng h·ª£p l·ªá. C√°c game ƒë∆∞·ª£c h·ªó tr·ª£: Luckywin, Hit Club, Sunwin.", parse_mode='Markdown')
        return

    if not GAME_CONFIGS[matched_game]['maintenance_mode']:
        bot.reply_to(message, f"Game **{GAME_CONFIGS[matched_game]['game_name_vi']}** kh√¥ng ·ªü tr·∫°ng th√°i b·∫£o tr√¨.", parse_mode='Markdown')
        return

    GAME_CONFIGS[matched_game]['maintenance_mode'] = False
    GAME_CONFIGS[matched_game]['maintenance_reason'] = ""
    save_bot_status() # Save game status

    bot.reply_to(message, f"‚úÖ ƒê√£ b·ªè tr·∫°ng th√°i b·∫£o tr√¨ cho game **{GAME_CONFIGS[matched_game]['game_name_vi']}**.", parse_mode='Markdown')

    # Notify all users previously receiving predictions for this game
    for user_id_int in list(GAME_CONFIGS[matched_game]['users_receiving']):
        try:
            bot.send_message(user_id_int, 
                             f"üéâ **TH√îNG B√ÅO:** Game **{GAME_CONFIGS[matched_game]['game_name_vi']}** ƒë√£ ho·∫°t ƒë·ªông tr·ªü l·∫°i! B·∫°n c√≥ th·ªÉ ti·∫øp t·ª•c nh·∫≠n d·ª± ƒëo√°n.", 
                             parse_mode='Markdown')
        except Exception:
            pass

@bot.message_handler(commands=['override'])
def add_override_permission(message):
    if not is_admin(message.chat.id):
        bot.reply_to(message, "B·∫°n kh√¥ng c√≥ quy·ªÅn s·ª≠ d·ª•ng l·ªánh n√†y.")
        return
    
    args = telebot.util.extract_arguments(message.text).split()
    if not args or not args[0].isdigit():
        bot.reply_to(message, "C√∫ ph√°p sai. V√≠ d·ª•: `/override <id_nguoi_dung>`", parse_mode='Markdown')
        return
    
    target_user_id_str = args[0]
    if target_user_id_str not in user_data:
        user_data[target_user_id_str] = {
            'username': "UnknownUser",
            'expiry_date': None,
            'is_ctv': False,
            'banned': False,
            'ban_reason': None,
            'override_maintenance': True, # Grant permission
            'receiving_games': {game: True for game in GAME_CONFIGS.keys()}
        }
    else:
        user_data[target_user_id_str]['override_maintenance'] = True
    
    save_user_data(user_data)
    bot.reply_to(message, f"ƒê√£ c·∫•p quy·ªÅn override b·∫£o tr√¨ cho user ID `{target_user_id_str}`.")
    try:
        bot.send_message(int(target_user_id_str), "üéâ B·∫°n ƒë√£ ƒë∆∞·ª£c c·∫•p quy·ªÅn b·ªè qua tr·∫°ng th√°i b·∫£o tr√¨ c·ªßa game!")
    except Exception:
        pass

@bot.message_handler(commands=['unoverride'])
def remove_override_permission(message):
    if not is_admin(message.chat.id):
        bot.reply_to(message, "B·∫°n kh√¥ng c√≥ quy·ªÅn s·ª≠ d·ª•ng l·ªánh n√†y.")
        return
    
    args = telebot.util.extract_arguments(message.text).split()
    if not args or not args[0].isdigit():
        bot.reply_to(message, "C√∫ ph√°p sai. V√≠ d·ª•: `/unoverride <id_nguoi_dung>`", parse_mode='Markdown')
        return
    
    target_user_id_str = args[0]
    if target_user_id_str in user_data:
        user_data[target_user_id_str]['override_maintenance'] = False
        save_user_data(user_data)
        bot.reply_to(message, f"ƒê√£ x√≥a quy·ªÅn override b·∫£o tr√¨ c·ªßa user ID `{target_user_id_str}`.")
        try:
            bot.send_message(int(target_user_id_str), "‚ùå Quy·ªÅn b·ªè qua tr·∫°ng th√°i b·∫£o tr√¨ c·ªßa b·∫°n ƒë√£ b·ªã g·ª° b·ªè.")
        except Exception:
            pass
    else:
        bot.reply_to(message, f"Kh√¥ng t√¨m th·∫•y ng∆∞·ªùi d√πng c√≥ ID `{target_user_id_str}`.")

@bot.message_handler(commands=['stats'])
def show_prediction_stats(message):
    if not is_admin(message.chat.id):
        bot.reply_to(message, "B·∫°n kh√¥ng c√≥ quy·ªÅn s·ª≠ d·ª•ng l·ªánh n√†y.")
        return
    
    args = telebot.util.extract_arguments(message.text).lower().split()
    
    stats_message = "üìä **TH·ªêNG K√ä D·ª∞ ƒêO√ÅN C·ª¶A BOT** üìä\n\n"
    
    if not args: # Show all games stats
        for game_key, config in GAME_CONFIGS.items():
            stats = config['prediction_stats']
            total = stats['total']
            correct = stats['correct']
            wrong = stats['wrong']
            accuracy = (correct / total * 100) if total > 0 else 0
            
            stats_message += (
                f"**{config['game_name_vi']}**:\n"
                f"  T·ªïng phi√™n d·ª± ƒëo√°n: `{total}`\n"
                f"  D·ª± ƒëo√°n ƒë√∫ng: `{correct}`\n"
                f"  D·ª± ƒëo√°n sai: `{wrong}`\n"
                f"  T·ª∑ l·ªá ch√≠nh x√°c: `{accuracy:.2f}%`\n\n"
            )
    else: # Show specific game stats
        game_arg = args[0]
        matched_game = None
        for game_key, config in GAME_CONFIGS.items():
            if game_key == game_arg or config['game_name_vi'].lower().replace(" ", "") == game_arg.replace(" ", ""):
                matched_game = game_key
                break
        
        if not matched_game:
            bot.reply_to(message, "T√™n game kh√¥ng h·ª£p l·ªá. C√°c game ƒë∆∞·ª£c h·ªó tr·ª£: Luckywin, Hit Club, Sunwin.", parse_mode='Markdown')
            return
        
        config = GAME_CONFIGS[matched_game]
        stats = config['prediction_stats']
        total = stats['total']
        correct = stats['correct']
        wrong = stats['wrong']
        accuracy = (correct / total * 100) if total > 0 else 0
        
        stats_message += (
            f"**{config['game_name_vi']}**:\n"
            f"  T·ªïng phi√™n d·ª± ƒëo√°n: `{total}`\n"
            f"  D·ª± ƒëo√°n ƒë√∫ng: `{correct}`\n"
            f"  D·ª± ƒëo√°n sai: `{wrong}`\n"
            f"  T·ª∑ l·ªá ch√≠nh x√°c: `{accuracy:.2f}%`\n\n"
        )

    bot.reply_to(message, stats_message, parse_mode='Markdown')

# --- Flask Routes cho Keep-Alive ---
@app.route('/')
def home():
    return "Bot is alive and running!"

@app.route('/health')
def health_check():
    return "OK", 200

# --- Kh·ªüi t·∫°o bot v√† c√°c lu·ªìng khi Flask app kh·ªüi ƒë·ªông ---
@app.before_request
def start_bot_threads():
    global bot_initialized
    with bot_init_lock:
        if not bot_initialized:
            print("LOG: ƒêang kh·ªüi t·∫°o lu·ªìng bot v√† d·ª± ƒëo√°n...")
            sys.stdout.flush()
            
            # Load initial data
            load_user_data()
            load_cau_patterns()
            load_codes()
            load_bot_status() # Load bot status and game configs

            # Start prediction loop for each game in a separate thread
            for game_name in GAME_CONFIGS.keys():
                prediction_stop_events[game_name] = Event()
                prediction_thread = Thread(target=prediction_loop, args=(game_name, prediction_stop_events[game_name],))
                prediction_thread.daemon = True 
                prediction_thread.start()
                print(f"LOG: Lu·ªìng d·ª± ƒëo√°n cho {game_name} ƒë√£ kh·ªüi ƒë·ªông.")
                sys.stdout.flush()

            # Start bot polling in a separate thread
            polling_thread = Thread(target=bot.infinity_polling, kwargs={'none_stop': True})
            polling_thread.daemon = True 
            polling_thread.start()
            print("LOG: Lu·ªìng Telegram bot polling ƒë√£ kh·ªüi ƒë·ªông.")
            sys.stdout.flush()
            
            bot_initialized = True
            print("LOG: Bot ƒë√£ ƒë∆∞·ª£c kh·ªüi t·∫°o ho√†n t·∫•t.")

# --- ƒêi·ªÉm kh·ªüi ch·∫°y ch√≠nh cho Gunicorn/Render ---
if __name__ == '__main__':
    port = int(os.environ.get('PORT', 5000))
    print(f"LOG: Kh·ªüi ƒë·ªông Flask app tr√™n c·ªïng {port}")
    sys.stdout.flush()
    app.run(host='0.0.0.0', port=port, debug=False)
